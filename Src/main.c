/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "Global.h"
#include "Clocks.h"
#include "I2C_EEPROM.h"
#include "GPIO.h"
#include "LPTIM.h"
#include "USART_DMA.h"
#include "AM2302.h"
#include "RTC.h"
#include "Queues.h"
#include "NVIC.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

//Sensor variables
uint16_t RH_data = 0;
uint16_t temperature_data = 0;

//Latest collected sensor data
uint8_t message_block_sensor[MESSAGE_BLOCK_BYTES] = {0}; //Sensor data, time 4x uint8_t, date 4x uint8_t, temperature 2x uint8_t, humidity 2x uint8_t
uint8_t message_block_internal[MESSAGE_BLOCK_BYTES] = {0}; //For internal message generation
uint8_t message_block_EEPROM_read[MESSAGE_BLOCK_BYTES] = {0}; //For EEPROM read message generation

//Device Status
uint32_t device_status = 0;

int main(void)
{
	//DMA Channel Utilization
	//Ch1 On message reception from server usart2_RX_buffer to message_queue
	//Ch4 USART2_TX to usart2_TX_buffer
	//Ch5 USART2_RX to usart2_RX_buffer

	//Initialize Clock
	intialize_Clock_HSI16();
	set_system_clock();
	initialize_LSE_Clock();

	//Initialize GPIO_Clock
	initialize_GPIOA_Clock();
	initialize_GPIOB_Clock();

	//Initialize Peripheral Clock
	initialize_I2C1_Clock();
	initialize_LPTIM1_Clock();
	initialize_USART2_Clock();
	initialize_DMA_Clock();

	//Initialize EXTI
	intialize_EXTI_RTC();

	//Initialize NVIC
	intialize_NVIC_I2C1();
	initialize_NVIC_LPTIM1();
	intialize_NVIC_USART2();
	intialize_NVIC_DMA_CH47();
	intialize_NVIC_RTC();
	intialize_NVIC_AES_RNG_LPUART1(); //Global queue processing interrupt
	initialize_NVIC_interrupt_priorities(); //Sets interrupt priorities

	//Initialize GPIO Pins
	intialize_GPIO_I2C1();
	initialize_GPIOA_GPO_PP(7); //For LPTIM calibration - erase later
	intialize_GPIO_USART2();
	initialize_GPIO_AM2302();

	//Initialize Peripherals
	initialize_I2C1();
	initialize_LPTIM();
	initialize_USART2_DMA();
	initialize_USART2();
	intialize_RTC_Clock();

	//Initialize RTC variables
	RTC_AlarmA_Init_Sec(); //Mask: Alarm A will look for seconds match only

	//Initialize EEPROM variables
	EEPROM_Reset_Data_Pointers(EEPROM_CHIP1_ADDRESS); //Reset EEPROM write pointer and data block count (pointer on the EEPROM chip)
	EEPROM_Reset_Data_Pointers(EEPROM_CHIP2_ADDRESS); //Reset EEPROM write pointer and data block count (pointer on the EEPROM chip)

	//-----------Debug
	//Prepare data to be sent
	for(int i=0;i<DATA_BLOCK_BYTES;i++){
		EEPROM_send_data[i]=i+30;
	}

	//I2C_EEPROM_Write(0x01, 0x0001, 63, 0x1);
	//I2C_EEPROM_Write(0x0003, 0x04);
	//EEPROM_Store_Data_Block(EEPROM_CHIP1_ADDRESS); //Uses EEPROM_send_data (global variable)

	//Prepare data to be sent
	for(int i=0;i<DATA_BLOCK_BYTES;i++){
		EEPROM_send_data[i]=i+40;
	}

	//EEPROM_Store_Data_Block(EEPROM_CHIP1_ADDRESS); //Uses EEPROM_send_data (global variable)
	//I2C_EEPROM_Read(0x01, 0x0000, (DATA_BLOCK_BYTES*2+4));

    /* Loop forever */
 	for(;;);
}

//Parameter is the first data byte pointer
void get_mcu_serial(uint8_t* target){
	//DEVICE_ID1
	*target = DEVICE_ID1;
	*(target + 1) = (DEVICE_ID1 >> 8);
	*(target + 2) = (DEVICE_ID1 >> 16);
	*(target + 3) = (DEVICE_ID1 >> 24);

	//DEVICE_ID2
	*(target + 4) = DEVICE_ID2;
	*(target + 5) = (DEVICE_ID2 >> 8);
	*(target + 6) = (DEVICE_ID2 >> 16);
	*(target + 7) = (DEVICE_ID2 >> 24);

	//DEVICE_ID3
	*(target + 8) = DEVICE_ID3;
	*(target + 9) = (DEVICE_ID3 >> 8);
	*(target + 10) = (DEVICE_ID3 >> 16);
	*(target + 11) = (DEVICE_ID3 >> 24);
}

//Adds message label to a specified byte in the message array
void label_message_type(uint8_t byteNumber, uint8_t label, uint8_t* message){
	*(message + byteNumber) = label;
}

void Get_Data_From_Sensors(uint8_t* message){
	//If there is an error in transmission try again until max tries
	uint8_t c = 1;
	uint8_t noTries = 0;
	while (c != 0 && noTries <= SENSORS_MAX_GET_DATA_TRIES){
		c = AM2302_Request_Data(&RH_data, &temperature_data); //Updates global variables: RH_data, Temperature_data
	}

	//In case the max number of tries have been reached (Error in communication)
	if (noTries == SENSORS_MAX_GET_DATA_TRIES){
		switch (c) {
			case 1:
				device_status |= BIT1; //AM2302 Counter timed out
				break;
			case 2:
				device_status |= BIT2; //AM2302 Check_sum failed
				break;
		}
	}

	//Add the data on message_block array
	*(message + 9) = RH_data;
	*(message + 10) = (RH_data >> 8);
	*(message + 11) = temperature_data;
	*(message + 12) = (temperature_data >> 8);
}

void LPTIM1_IRQHandler(){
	//MUST CLEAR THIS FLAG
	LPTIM_ICR |= (1 << 1); //ARRMCF: Autoreload match clear flag Writing 1 to this bit clears the ARRM flag in the LPTIM_ISR register

	/*seconds = seconds + 1;
	if (seconds == 60){
		seconds = 0;
		minutes++;
	}

	if (minutes >= 99){
		minutes = 0;
	}

	LED_Update();*/
}

//The global_msg_queue_processing_index is updated during global_message_queue_get()
void Process_Global_Message_Queue(){
	//Triggered by PendSV interrupt
	while(!global_message_queue_is_empty()){
		//The first byte determines the message type
		uint8_t* pCurrentMessage = global_message_queue_get(); //Gets the pointer to oldest message in global message queue - updates global_msg_queue_processing_index
		switch (*(pCurrentMessage)) {
			case 0x01:
				//Server requests unprocessed messages stored on an EEPROM chip
				if(!EEPROM_Get_FIFO_Data_Block(*(pCurrentMessage + 1))){
					//There are not unprocessed messages stored on the specified chip - Lets server know
					label_message_type(0x00, 0x02, message_block_internal); //Label message type
					label_message_type(0x01, *(pCurrentMessage + 1), message_block_internal); //Add the requested chip address
					internal_message_queue_add(message_block_internal); //Add this message to queue
				}
				break;
			case 0x02:
				//No unprocessed data on chip message to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 0x03:
				//EEPROM message block to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 0x04:
				//EEPROM chip serial number message to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 0x05:
				//Message includes RTC update message confirmation to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 0x06:
				//Message includes EEPROM chip serial number to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 0x07:
				//Message includes notification that sampling period set request was received to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 0x08:
				//Message includes notification that sampling period set request was received to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 'a':
				//Message includes sensor data to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 'b':
				//Clock data from server - Set RTC clock (time then date)
				RTC_Set_Date_Time(pCurrentMessage);
				label_message_type(0x00, 0x05, message_block_internal);
				internal_message_queue_add(message_block_internal); //Add this message to queue
				break;
			case 'c':
				//Server requests RTC clock data (c and all zeros) - Generate new message to be sent to server
				RTC_Read_Date_Time(message_block_internal); //Updates date and time on message_block
				label_message_type(0x00, 'd', message_block_internal);
				internal_message_queue_add(message_block_internal); //Add this message to queue
				break;
			case 'd':
				//RTC time and date message to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 'e':
				//Server requests device component information
				get_mcu_serial((message_block_internal + 1));
				label_message_type(0x00, 'f', message_block_internal);
				internal_message_queue_add(message_block_internal); //Add this message to queue
				EEPROM_Get_Serial_Number(EEPROM_CHIP1_ADDRESS); //Message automatically added to the EEPROM receive queue
				EEPROM_Get_Serial_Number(EEPROM_CHIP2_ADDRESS); //Message automatically added to the EEPROM receive queue
				break;
			case 'f':
				//Message includes device serial information to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 'g':
				//Server sets the RTC_AlarmA_Period
				RTC_AlarmA_Set_Period(pCurrentMessage, &RTC_Alarm_Unit_Status);
				label_message_type(0x00, 0x07, message_block_internal);
				internal_message_queue_add(message_block_internal); //Add this message to queue
				break;
			case 'h':
				//Server requests Alarm A sampling period
				RTC_Get_AlarmA_Period(message_block_internal);
				label_message_type(0x00, 0x09, message_block_internal); //Notifies server of sampling  stop
				internal_message_queue_add(message_block_internal); //Add this message to queue
				break;
			case 'i':
				//Message includes Alarm A sampling period to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 'j':
				//Server wants to set the first alarm for Alarm A - The sampling period must be set first
				if (RTC_AlarmA_Period_Is_Set(device_status)){
					//Set the first Alarm A
					RTC_AlarmA_Set_First_Alarm(pCurrentMessage);
					label_message_type(0x00, 0x08, message_block_internal);
					internal_message_queue_add(message_block_internal); //Add this message to queue
				} else {
					//Notify server that sampling period has not been set
					label_message_type(0x00, 'k', message_block_internal);
					internal_message_queue_add(message_block_internal); //Add this message to queue
				}
				break;
			case 'k':
				//Message includes server notification that sampling period has not been set
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 'l':
				//Server requests current Alarm A
				RTC_Get_AlarmA_Current(message_block_internal);
				label_message_type(0x00, 'm', message_block_internal);
				internal_message_queue_add(message_block_internal); //Add this message to queue
				break;
			case 'm':
				//Message includes current Alarm A time to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			case 'n':
				//Server requests that Alarm A be disabled (Stop sampling)
				RTC_AlarmA_Disable();
				label_message_type(0x00, 'm', message_block_internal);
				internal_message_queue_add(message_block_internal); //Add this message to queue
				break;
			case 'o':
				//Server requests ping response
				label_message_type(0x00, 'p', message_block_internal);
				internal_message_queue_add(message_block_internal); //Add this message to queue
				break;
			case 'p':
				//Message includes ping response to be sent to server
				Usart2_Copy_Into_TX_Buffer(pCurrentMessage); //Copies message data into UART TX Buffer
				USART2_Send_Data(MESSAGE_BLOCK_BYTES); //UART Sends data to server
				break;
			default:
				//Unknown message detected
				device_status |= BIT8;
		}
	}
}

void PendSV_Handler(){
	PendSv_Clear(); //Clear PendSV interrupt
	global_message_queue_combine(); //Combine messages into global message queue
	Process_Global_Message_Queue(); //Process the messages in global queue
}

void AES_RNG_LPUART1_IRQHandler(){
	Clear_Pending_AES_RNG_LPUART1_Interrupt();
	global_message_queue_combine(); //Combine messages into global message queue
	Process_Global_Message_Queue(); //Process the messages in global queue
}

//Is only ever using Alarm A
void RTC_IRQHandler(){
	//Clear the EXTI pending interrupt register
	EXTI_PR |= BIT17;

	//This flag is set by hardware when the time/date registers (RTC_TR and RTC_DR) match the Alarm A register (RTC_ALRMAR).
	//The bits ALRAF, ALRBF, WUTF and TSF are cleared 2 APB clock cycles after programming them to 0.
	RTC_ISR &= ~BIT8; //Bit 8 ALRAF: Alarm A flag, This flag is cleared by software by writing 0.

	//Collect date and time data (time-stamp)
	RTC_Read_Date_Time(message_block_sensor); //Updates message_block array (global) with date and time

	//Collect Sensor data
	Get_Data_From_Sensors(message_block_sensor); //Updates message_block_sensor array (global) with sensor data

	//Label message type
	label_message_type(0x00, 'a', message_block_sensor);

	//Add message to queue to store the data on server or EEPROM
	sensor_message_queue_add(message_block_sensor);

	//Set new alarm - increment old alarm time RTC_AlarmA_Period (seconds)
	RTC_Increment_AlarmA(RTC_AlarmA_Period);

	//Enable PendSV interrupt
	Set_Pending_AES_RNG_LPUART1_Interrupt(); //Set PendSV interrupt to process message queues
}
