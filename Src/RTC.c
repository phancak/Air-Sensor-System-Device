/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "RTC.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * Notes
 *
 * The RTC peripheral, RTC clock source selection (in RCC_CSR) and the backup registers
 * are reset only when one of the following events occurs:
 * • A software reset, triggered by setting the RTCRST bit in the RCC_CSR register (see
 *   Section 7.3.20)
 * • Power reset (BOR/POR/PDR).
 *
 * Once the RTC clock source have been selected, the only possible way of modifying the
 * selection is to set the RTCRST bit in the RCC_CSR register, or by a POR.
 *
 * The LSEON, LSEBYP, RTCSEL,LSEDRV and RTCEN bits in the RCC control and status
 * register (RCC_CSR) are in the RTC domain. As these bits are write protected after reset,
 * the DBP bit in the Power control register (PWR_CR) has to be set to be able to modify them.
 * Refer to Section 6.1.2: RTC and RTC backup registers for further information. These bits
 * are only reset after a RTC domain reset (see Section 6.1.2). Any internal or external reset
 * does not have any effect on them.
 *
 * RTC registers access
 * After reset, the RTC Registers (RTC registers and RTC backup registers) are protected
 * against possible stray write accesses. To enable access to the RTC Registers, proceed as
 * follows:
 * 1. Enable the power interface clock by setting the PWREN bits in the RCC_APB1ENR
 *    register.
 * 2. Set the DBP bit in the PWR_CR register (see Section 6.4.1).
 * 3. Select the RTC clock source through RTCSEL[1:0] bits in RCC_CSR register.
 * 4. Enable the RTC clock by programming the RTCEN bit in the RCC_CSR register.
 */

uint8_t RTC_Alarm_Unit_Status = 0; //BIT0: Seconds, BIT1: Minutes, BIT2: Hours
uint8_t RTC_Alarm_Minute_Increment = 0; //-------
uint32_t RTC_AlarmA_Period = 0;
uint8_t RTC_Alarm_Time_Minute = 0; //Latest alarm set in minutes ------
uint8_t RTC_Alarm_Time_Seconds = 0; //Latest alarm set in seconds ------

/*
int main(void)
{
	uint32_t timeRegister;
	uint32_t dateRegister;
	//uint32_t timeRegisterRead;
	//uint32_t dateRegisterRead;

	//Initialize date time variables
	uint32_t yearTens = 0x02;
	uint32_t yearUnits = 0x03;
	uint32_t weekDay = 0x03; //Wednesday = 0x11
	uint32_t monthTens = 0x01;
	uint32_t monthUnits = 0x02;
	uint32_t dateTens = 0x01;
	uint32_t dateUnits = 0x03;
	uint32_t hourTens = 0x00;
	uint32_t hourUnits = 0x03;
	uint32_t minuteTens = 0x00;
	uint32_t minuteUnits = 0x04;
	uint32_t secondTens = 0x00;
	uint32_t secondUnits = 0x03;

	dateRegister = (yearTens << 20) | (yearUnits << 16) | (weekDay << 13) | (monthTens << 12) | (monthUnits << 8) | (dateTens << 4) | (dateUnits);
	timeRegister = (hourTens << 20) | (hourUnits << 16) | (minuteTens << 12) | (minuteUnits << 8) | (secondTens << 4) | (secondUnits << 0);

	intialize_NVIC_RTC();
	initialize_LSE_Clock();
	intialize_RTC_Clock();
	RTC_Set_Date_Time(&timeRegister, &dateRegister);
	RTC_Alarm_Unit_Flag = 0; //0: Seconds, 1: Minutes
	RTC_AlarmA_Init_Sec(); //Mask: Alarm A will look for seconds match only
*/
    /* Loop forever */
	//for(;;);
//}

void intialize_RTC_Clock(){
	//RTC register write protection
	RTC_WPR |= 0xCA; //Bits 7:0 KEY[7:0]: Write protection key
	RTC_WPR |= 0x53;

	//RCC_CSR |= BIT19; //Bit 19 RTCRST: RTC software reset bit, 1: Resets the RTC peripheral, its clock source selection and the backup registers.

	//RTC registers access
	//After reset, the RTC Registers (RTC registers and RTC backup registers) are protected
	//against possible stray write accesses. To enable access to the RTC Registers, proceed as
	//follows:
	//1. Enable the power interface clock by setting the PWREN bits in the RCC_APB1ENR
	//   register.
	//2. Set the DBP bit in the PWR_CR register (see Section 6.4.1).
	//3. Select the RTC clock source through RTCSEL[1:0] bits in RCC_CSR register.
	//4. Enable the RTC clock by programming the RTCEN bit in the RCC_CSR register.
	RCC_APB1ENR |= BIT28; //PWREN: Power interface clock enable bit, 1: Power interface clock enabled

	PWR_CR |= (1 << 8); //DBP: Disable backup write protection
	RCC_CSR &= ~BIT19;
	RCC_CSR |= (0x01 << 16); //RTCSEL[1:0]: RTC clock source selection bits, 01: LSE oscillator clock used as RTC clock
	//Once the RTC clock source has been selected it cannot be switched until RTCRST is set or
	//a Power On Reset occurred. The only exception is if the LSE oscillator clock was selected, if
	//the LSE clock stops and it is detected by the CSSLSE, in that case the clock can be switched.
	//RCC_CSR |= BIT19; //RTCRST: RTC software reset bit, 1: Resets the RTC peripheral, its clock source selection and the backup registers.
	RCC_CSR |= BIT18; //RTCEN: RTC clock enable bit, It is reset by setting the RTCRST bit or by a POR.

	//RTC_CR |= BIT8; //ALRAE: Alarm A enable
	//RTC_CR |= BIT12; //Bit 12 ALRAIE: Alarm A interrupt enable

}

void RTC_AlarmA_Interrupt_Enable(){
	RTC_CR |= BIT12; //Bit 12 ALRAIE: Alarm A interrupt enable
}

void RTC_AlarmA_Interrupt_Disable(){
	RTC_CR &= ~BIT12; //Bit 12 ALRAIE: Alarm A interrupt enable, 0: Alarm A interrupt disabled
}

//Inputs formated for RTC_TR and RTC_DR
void RTC_Set_Date_Time(uint8_t* message){
	//The updated time shows up in the RTC_TR and RTC_DR registers only after exit of initiation mode

	//Prepares time and date data
	uint32_t timeRegister = *(message + 1) | ((*(message + 2)) << 8) | ((*(message + 3)) << 16) | ((*(message + 4)) << 24);
	uint32_t dateRegister = *(message + 5) | ((*(message + 6)) << 8) | ((*(message + 7)) << 16) | ((*(message + 8)) << 24);

	/*Calendar initialization and configuration
	To program the initial time and date calendar values, including the time format and the
	prescaler configuration, the following sequence is required:
	1. Set INIT bit to 1 in the RTC_ISR register to enter initialization mode. In this mode, the
	   calendar counter is stopped and its value can be updated.
	2. Poll INITF bit of in the RTC_ISR register. The initialization phase mode is entered when
	   INITF is set to 1. It takes around 2 RTCCLK clock cycles (due to clock synchronization).
	3. To generate a 1 Hz clock for the calendar counter, program both the prescaler factors in
	   RTC_PRER register.
	4. Load the initial time and date values in the shadow registers (RTC_TR and RTC_DR),
	   and configure the time format (12 or 24 hours) through the FMT bit in the RTC_CR
	   register.
	5. Exit the initialization mode by clearing the INIT bit. The actual calendar counter value is
	   then automatically loaded and the counting restarts after 4 RTCCLK clock cycles.
	   When the initialization sequence is complete, the calendar starts counting. */

	//(RCC_CIER & BIT1) Bit 1 LSERDYIE: LSE ready interrupt flag

	//1. Write ‘0xCA’ into the RTC_WPR register.
	//2. Write ‘0x53’ into the RTC_WPR register.
	RTC_WPR |= 0xCA; //Bits 7:0 KEY[7:0]: Write protection key
	RTC_WPR |= 0x53;

	RTC_ISR |= BIT7; //INIT: Initialization mode
	//1: Initialization mode used to program time and date register (RTC_TR and RTC_DR), and
	//prescaler register (RTC_PRER). Counters are stopped and start counting from the new
	//value when INIT is reset.
	while ((RTC_ISR & BIT6)==0){
		////INITF: Initialization flag, 1: Calendar registers update is allowed
	}

	//The asynchronous prescaler division factor is set to 128, and the synchronous division
	//factor to 256, to obtain an internal clock frequency of 1 Hz (ck_spre) with an LSE frequency
	//of 32.768 kHz.
	//A 7-bit asynchronous prescaler configured through the PREDIV_A bits of the RTC_PRER register.
	//A 15-bit synchronous prescaler configured through the PREDIV_S bits of the RTC_PRER register.
	//RTC_PRER |= (0x80 << 16); //Bits 22:16 PREDIV_A[6:0]: Asynchronous prescaler factor (Left at reset value 125)
	//RTC_PRER |= (0x100 << 0); //Bits 14:0 PREDIV_S[14:0]: Synchronous prescaler factor (Left at reset value 255)

	RTC_TR = timeRegister;
	RTC_DR = dateRegister;
	RTC_CR &= ~(BIT6); //FMT: Hour format, 0: 24 hour/day format (Reset value)

	while ((RTC_ISR & BIT5)!=0){ //Bit 5 RSF: Registers synchronization flag
		/*
		This bit is set by hardware each time the calendar registers are copied into the shadow
		registers (RTC_SSR, RTC_TR and RTC_DR). This bit is cleared by hardware in initialization
		mode, while a shift operation is pending (SHPF=1), or when in bypass shadow register mode
		(BYPSHAD=1). This bit can also be cleared by software.
		It is cleared either by software or by hardware in initialization mode.
		 */
	}

	RTC_ISR &= ~BIT7; //INIT: Initialization mode, 0: Free running mode

	//Update device status
	device_status |= BIT7;
}

//Copies RTC date and time information to message_block_sensor array
void RTC_Read_Date_Time(uint8_t* message){
	//When the application reads the calendar registers, it accesses the content of the shadow
	//registers. It is possible to make a direct access to the calendar registers by setting the
	//BYPSHAD control bit in the RTC_CR register. By default, this bit is cleared, and the user
	//accesses the shadow registers.

	//Time from RTC_TR register
	for (int i=0;i<4;i++){
		*(message + 1 + i) = (RTC_TR >> (i*8));
	}

	//Date from RTC_DR register
	for (int i=0;i<4;i++){
		*(message + 5 + i) = (RTC_DR >> (i*8));
	}
}

//Initializes the RTC Alarm A mask to minutes
void RTC_AlarmA_Init_Min(){
	RTC_ALRMAR &= ~(0xFFFFFFFF); //Clears the alarm values
	RTC_ALRMAR |= BIT31; //MSK4: Alarm A date mask, 1: Date/day don’t care in Alarm A comparison
	RTC_ALRMAR |= BIT30; //WDSEL: Week day selection, 1: DU[3:0] represents the week day. DT[1:0] is don’t care.
	RTC_ALRMAR |= BIT23; //MSK3: Alarm A hours mask, 1: Hours don’t care in Alarm A comparison
	RTC_ALRMAR &= ~BIT15; //MSK2: Alarm A minutes mask, 0: Alarm A set if the minutes match
	RTC_ALRMAR |= BIT7; //MSK1: Alarm A seconds mask, 1: Seconds don’t care in Alarm A comparison
}

//Initializes the RTC Alarm A mask to seconds
void RTC_AlarmA_Init_Sec(){
	RTC_ALRMAR &= ~(0xFFFFFFFF); //Clears the alarm values
	RTC_ALRMAR |= BIT31; //MSK4: Alarm A date mask, 1: Date/day don’t care in Alarm A comparison
	RTC_ALRMAR |= BIT30; //WDSEL: Week day selection, 1: DU[3:0] represents the week day. DT[1:0] is don’t care.
	RTC_ALRMAR |= BIT23; //MSK3: Alarm A hours mask, 1: Hours don’t care in Alarm A comparison
	RTC_ALRMAR |= BIT15; //MSK2: Alarm A minutes mask, 1: Minutes don’t care in Alarm A comparison
	RTC_ALRMAR &= ~BIT7; //MSK1: Alarm A seconds mask, 0: Alarm A set if the seconds match
}

//Initializes the RTC Alarm A mask to minutes and seconds
void RTC_AlarmA_Init_Min_Sec(){
	RTC_ALRMAR &= ~(0xFFFFFFFF); //Clears the alarm values
	RTC_ALRMAR |= BIT31; //MSK4: Alarm A date mask, 1: Date/day don’t care in Alarm A comparison
	RTC_ALRMAR |= BIT30; //WDSEL: Week day selection, 1: DU[3:0] represents the week day. DT[1:0] is don’t care.
	RTC_ALRMAR |= BIT23; //MSK3: Alarm A hours mask, 1: Hours don’t care in Alarm A comparison
	RTC_ALRMAR &= ~BIT15; //MSK2: Alarm A minutes mask, 0: Alarm A set if the minutes match
	RTC_ALRMAR &= ~BIT7; //MSK1: Alarm A seconds mask, 0: Alarm A set if the seconds match
}

//Returns one if alarm period has been set
uint8_t RTC_AlarmA_Period_Is_Set(uint32_t device_status){
	if (device_status & BIT6)
		return 1;
	else
		return 0;
}

void RTC_AlarmA_Enable(){
	RTC_CR |= BIT8; //Enable Alarm A
}

void RTC_AlarmA_Disable(){
	RTC_CR &= ~BIT8; //Disable Alarm A
}

//Initializes the RTC Alarm A based on RTC_Alarm_Unit_Status - Called by RTC_AlarmA_Set_Period function
void RTC_AlarmA_Init(uint8_t RTC_Alarm_Unit_Status){
	RTC_WPR |= 0xCA; //Bits 7:0 KEY[7:0]: Write protection key
	RTC_WPR |= 0x53;

	//1. Clear ALRAE in RTC_CR to disable Alarm A.
	RTC_CR &= ~BIT8; //ALRAE: Alarm A enable, 0: Alarm A disabled

	//Bit 0 ALRAWF: Alarm A write flag, 1: Alarm A update allowed
	while ((RTC_ISR & BIT0)==0){
		//This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.
		//It is cleared by hardware in initialization mode.
	}

	//2. Program the Alarm A registers (RTC_ALRMASSR/RTC_ALRMAR).
	RTC_ALRMAR &= ~(0xFFFFFFFF); //Clears the alarm values
	RTC_ALRMAR |= BIT31; //MSK4: Alarm A date mask, 1: Date/day don’t care in Alarm A comparison
	RTC_ALRMAR |= BIT30; //WDSEL: Week day selection, 1: DU[3:0] represents the week day. DT[1:0] is don’t care.
	RTC_ALRMAR |= (((RTC_Alarm_Unit_Status >> 2) & 0x01) << 23); //MSK3: Alarm A hours mask
	RTC_ALRMAR |= (((RTC_Alarm_Unit_Status >> 1) & 0x01) << 15); //MSK2: Alarm A minutes mask
	RTC_ALRMAR |= (((RTC_Alarm_Unit_Status >> 0) & 0x01) << 7);; //MSK1: Alarm A seconds mask

	//3. Set ALRAE in the RTC_CR register to enable Alarm A again.
	RTC_CR |= BIT8; //ALRAE: Alarm A enable, 1: Alarm A enabled
}

//First alarm is set as the next integer multiple of second, minute, or hour
void RTC_AlarmA_Set_First_Alarm(uint8_t* message){
	//Parses message for parameters
	uint8_t integer = *(message + 1);
	uint8_t time_unit = *(message + 2);

	//time_unit - 0: Second, 1: Minute, 2: Hour
	uint8_t hour_tens = 0;
	uint8_t hour_uints = 0;
	uint8_t minute_tens = 0;
	uint8_t minute_units = 0;
	uint8_t second_tens = 0;
	uint8_t second_units = 0;
	uint32_t time = 0;
	uint16_t multiple = 0;

	RTC_AlarmA_Enable();

	switch (time_unit){
		case 0:
			//Get current time
			second_units = ((RTC_TR >> 0) & 0x0F); //Sets SU[3:0]
			second_tens = ((RTC_TR >> 4) & 0x07); //Sets ST[2:0]
			time = second_units + second_tens*10;
			multiple = time/integer;
			//Can go over 60 seconds ---------
			RTC_AlarmA_Set_Sec(((multiple+1)*integer)%60); //Sets alarm A to the next integer multiple
			break;
		case 1:
			minute_units = ((RTC_TR >> 8) & 0x0F); //Sets MNU[3:0]
			minute_tens = ((RTC_TR >> 12) & 0x07); //Sets MNT[2:0]
			time = minute_units + minute_tens*10;
			multiple = time/integer;
			RTC_AlarmA_Set_Min(((multiple+1)*integer)%60); //Sets alarm A to the next integer multiple

			break;
		case 2:
			hour_uints = ((RTC_TR >> 16) & 0x0F); //Sets HU[3:0]
			hour_tens = ((RTC_TR >> 20) & 0x03); //Sets HT[1:0]
			time = hour_uints + hour_tens*10;
			multiple = time/integer;
			RTC_AlarmA_Set_Hr(((multiple+1)*integer)%24);
			break;
	}
}

void RTC_Write_Protection_Disable(){
	//RTC register write protection
	RTC_WPR |= 0xCA; //Bits 7:0 KEY[7:0]: Write protection key
	RTC_WPR |= 0x53;
}

void RTC_Write_Protection_Enable(){
	RTC_WPR |= 0xFFU;
}

void RTC_AlarmA_Set_Sec(uint8_t seconds){
	RTC_Write_Protection_Disable();
	RTC_AlarmA_Interrupt_Disable();

	//1. Clear ALRAE in RTC_CR to disable Alarm A.
	RTC_CR &= ~BIT8; //ALRAE: Alarm A enable, 0: Alarm A disabled

	//Bit 0 ALRAWF: Alarm A write flag, 1: Alarm A update allowed
	while ((RTC_ISR & BIT0)==0){
		//This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.
		//It is cleared by hardware in initialization mode.
	}

	//2. Program the Alarm A registers (RTC_ALRMASSR/RTC_ALRMAR).
	RTC_ALRMAR &= ~(0x7F << 0); //Clears ST[2:0] and SU[3:0]
	RTC_ALRMAR |= ((seconds%10) << 0); //Sets SU[3:0]
	RTC_ALRMAR |= ((seconds/10) << 4); //Sets ST[2:0]

	RTC_AlarmA_Interrupt_Enable();

	//3. Set ALRAE in the RTC_CR register to enable Alarm A again.
	RTC_CR |= BIT8; //ALRAE: Alarm A enable, 1: Alarm A enabled
}

//Loads RTC_AlarmA_Period into message_block_internal
void RTC_Get_AlarmA_Period(uint8_t* message_block_internal){
	*(message_block_internal + 1) = RTC_AlarmA_Period;
	*(message_block_internal + 2) = (RTC_AlarmA_Period >> 8);
	*(message_block_internal + 3) = (RTC_AlarmA_Period >> 16);
	*(message_block_internal + 4) = (RTC_AlarmA_Period >> 24);
}

void RTC_Get_AlarmA_Current(uint8_t* message_block_internal){
	*(message_block_internal + 1) = RTC_ALRMAR;
	*(message_block_internal + 2) = (RTC_ALRMAR >> 8);
	*(message_block_internal + 3) = (RTC_ALRMAR >> 16);
	*(message_block_internal + 4) = (RTC_ALRMAR >> 24);
}

//Automatically readjusts the Alarm A mask based on the size of increment in seconds
void RTC_AlarmA_Set_Period(uint8_t* message, uint8_t* RTC_Alarm_Unit_Status){
	uint32_t sampling_Period = 0;

	//Gets sampling period from message
	sampling_Period = *(message + 1) | (*(message + 2) << 8) | (*(message + 3) << 16) | (*(message + 4) << 24);

	RTC_AlarmA_Period = sampling_Period; //Global RTC alarm parameter

	//Adjusts Alarm A mask
	if (sampling_Period <= 60){
		*RTC_Alarm_Unit_Status = 0x06; //BIT0: Seconds
	} else if (sampling_Period > 60 && sampling_Period <= 3600){
		*RTC_Alarm_Unit_Status = 0x04; //BIT0: Seconds, BIT1: Minutes
	} else if (sampling_Period > 3600 && sampling_Period <= 86400){
		*RTC_Alarm_Unit_Status = 0x00; //BIT0: Seconds, BIT1: Minutes, BIT2: Hours
	}

	//Reinitializes the Alarm A mask - Selects the relevant time units for the time increase
	RTC_AlarmA_Init(*RTC_Alarm_Unit_Status);

	//Update device status register
	device_status |= BIT6;
}

void RTC_Increment_AlarmA(uint32_t sampling_Period){
	uint8_t hour_tens = 0;
	uint8_t hour_uints = 0;
	uint8_t minute_tens = 0;
	uint8_t minute_units = 0;
	uint8_t second_tens = 0;
	uint8_t second_units = 0;
	uint32_t timeSeconds = 0;

	//Get old alarm A values
	hour_uints = ((RTC_ALRMAR >> 16) & 0x0F); //Sets HU[3:0]
	hour_tens = ((RTC_ALRMAR >> 20) & 0x03); //Sets HT[1:0]
	minute_units = ((RTC_ALRMAR >> 8) & 0x0F); //Sets MNU[3:0]
	minute_tens = ((RTC_ALRMAR >> 12) & 0x07); //Sets MNT[2:0]
	second_units = ((RTC_ALRMAR >> 0) & 0x0F); //Sets SU[3:0]
	second_tens = ((RTC_ALRMAR >> 4) & 0x07); //Sets ST[2:0]

	//Calculate alarm time in seconds
	timeSeconds = second_units + second_tens*10 + (minute_units + minute_tens*10)*60 + (hour_uints + hour_tens*10)*3600;

	//Increment the latest alarm
	timeSeconds = (timeSeconds + sampling_Period)%86400; //86400 seconds in a day

	RTC_Write_Protection_Disable();
	RTC_AlarmA_Interrupt_Disable();

	//Modify the alarm A mask
	//1. Clear ALRAE in RTC_CR to disable Alarm A.
	RTC_CR &= ~BIT8; //ALRAE: Alarm A enable, 0: Alarm A disabled

	//Bit 0 ALRAWF: Alarm A write flag, 1: Alarm A update allowed
	while ((RTC_ISR & BIT0)==0){
		//This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.
		//It is cleared by hardware in initialization mode.
	}

	//2. Program the Alarm A registers (RTC_ALRMASSR/RTC_ALRMAR).
	//-----------
	//What if the alarm gets set to a time that has passed by the time it gets set-----
	RTC_ALRMAR &= ~(0x3F7F7F7F); //Clears the Alarm A register
	RTC_ALRMAR |= (((timeSeconds/3600)/10) << 20); //Sets HT[2:0]
	RTC_ALRMAR |= (((timeSeconds/3600)%10) << 16); //Sets HU[3:0]
	RTC_ALRMAR |= (((timeSeconds%3600)/60)/10 << 12); //Sets MNT[2:0]
	RTC_ALRMAR |= (((timeSeconds%3600)/60)%10 << 8); //Sets MNU[3:0]
	RTC_ALRMAR |= (((timeSeconds%3600)%60)/10 << 4); //Sets ST[2:0]
	RTC_ALRMAR |= (((timeSeconds%3600)%60)%10 << 0); //Sets SU[3:0]

	RTC_AlarmA_Interrupt_Enable();

	//3. Set ALRAE in the RTC_CR register to enable Alarm A again.
	RTC_CR |= BIT8; //ALRAE: Alarm A enable, 1: Alarm A enabled
}

//Sets minutes fields to zero
void RTC_AlarmA_Set_Min(uint8_t minute){
	RTC_Write_Protection_Disable();
	RTC_AlarmA_Interrupt_Disable();

	//1. Clear ALRAE in RTC_CR to disable Alarm A.
	RTC_CR &= ~BIT8; //ALRAE: Alarm A enable, 0: Alarm A disabled

	//Bit 0 ALRAWF: Alarm A write flag, 1: Alarm A update allowed
	while ((RTC_ISR & BIT0)==0){
		//This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.
		//It is cleared by hardware in initialization mode.
	}

	//2. Program the Alarm A registers (RTC_ALRMASSR/RTC_ALRMAR).
	RTC_ALRMAR &= ~(0x7F << 8); //Clears MNT[2:0] and MNU[3:0]
	RTC_ALRMAR &= ~(0x7F << 0); //Clears ST[2:0] and SU[3:0]
	RTC_ALRMAR |= ((minute%10) << 8); //Sets MNU[3:0]
	RTC_ALRMAR |= ((minute/10) << 12); //Sets MNT[2:0]

	RTC_AlarmA_Interrupt_Enable();

	//3. Set ALRAE in the RTC_CR register to enable Alarm A again.
	RTC_CR |= BIT8; //ALRAE: Alarm A enable, 1: Alarm A enabled
}

//Sets hours fields to zero
void RTC_AlarmA_Set_Hr(uint8_t hour){
	RTC_Write_Protection_Disable();
	RTC_AlarmA_Interrupt_Disable();

	//1. Clear ALRAE in RTC_CR to disable Alarm A.
	RTC_CR &= ~BIT8; //ALRAE: Alarm A enable, 0: Alarm A disabled

	//Bit 0 ALRAWF: Alarm A write flag, 1: Alarm A update allowed
	while ((RTC_ISR & BIT0)==0){
		//This bit is set by hardware when Alarm A values can be changed, after the ALRAE bit has been set to 0 in RTC_CR.
		//It is cleared by hardware in initialization mode.
	}

	//2. Program the Alarm A registers (RTC_ALRMASSR/RTC_ALRMAR).
	RTC_ALRMAR &= ~(0x7F << 16); //Clears HT[1:0] and HU[3:0]
	RTC_ALRMAR &= ~(0x7F << 8); //Clears MNT[2:0] and MNU[3:0]
	RTC_ALRMAR &= ~(0x7F << 0); //Clears ST[2:0] and SU[3:0]
	RTC_ALRMAR |= ((hour%10) << 16); //Sets HU[3:0]
	RTC_ALRMAR |= ((hour/10) << 20); //Sets HT[1:0]

	RTC_AlarmA_Interrupt_Enable();

	//3. Set ALRAE in the RTC_CR register to enable Alarm A again.
	RTC_CR |= BIT8; //ALRAE: Alarm A enable, 1: Alarm A enabled
}
