/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "Queues.h"

//Global message queue parameters
uint8_t global_message_queue[GLOBAL_MESSAGE_QUEUE_SIZE] = {0};
uint8_t global_msg_queue_processing_index = 0; //Tracks the position of incoming messages to be processed
uint8_t global_msg_queue_storage_index = 0; //Tracks index where incoming messages are to be stored
uint8_t global_msg_queue_full_flag = 0;

//Sensor message queue parameters
uint8_t sensor_message_queue[SENSOR_MESSAGE_QUEUE_SIZE] = {0};
uint8_t sensor_msg_queue_processing_index = 0; //Tracks the position of incoming messages to be processed
uint8_t sensor_msg_queue_storage_index = 0; //Tracks index where incoming messages are to be stored
uint8_t sensor_msg_queue_full_flag = 0;

//Server message queue parameters
uint8_t server_message_queue[SERVER_MESSAGE_QUEUE_SIZE] = {0};
uint8_t server_msg_queue_processing_index = 0; //Tracks the position of incoming messages to be processed
uint8_t server_msg_queue_storage_index = 0; //Tracks index where incoming messages are to be stored
uint8_t server_msg_queue_full_flag = 0;

//Internal message queue parameters
uint8_t internal_message_queue[INTERNAL_MESSAGE_QUEUE_SIZE] = {0};
uint8_t internal_msg_queue_processing_index = 0; //Tracks the position of incoming messages to be processed
uint8_t internal_msg_queue_storage_index = 0; //Tracks index where incoming messages are to be stored
uint8_t internal_msg_queue_full_flag = 0;

//Read from EEPROM queue parameters (Read data from EEPROM will arrive asynchronously)
uint8_t EEPROM_read_message_queue[EEPROM_READ_MESSAGE_QUEUE_SIZE] = {0};
uint8_t EEPROM_read_msg_queue_processing_index = 0; //Tracks the position of incoming messages to be processed
uint8_t EEPROM_read_msg_queue_storage_index = 0; //Tracks index where incoming messages are to be stored
uint8_t EEPROM_read_msg_queue_full_flag = 0;

void global_message_queue_combine(){
	//Move messages from sensor queue to global queue
	while(!sensor_message_queue_is_empty() && (global_msg_queue_full_flag == 0)){
		global_message_queue_add(sensor_message_queue_get());
	}

	//Move messages from server queue to global queue
	while(!server_message_queue_is_empty() && (global_msg_queue_full_flag == 0)){
		global_message_queue_add(server_message_queue_get());
	}

	//Move messages from internal queue to global queue
	while(!internal_message_queue_is_empty() && (global_msg_queue_full_flag == 0)){
		global_message_queue_add(internal_message_queue_get());
	}

	//Move messages from EEPROM read queue to global queue
	while(!EEPROM_read_message_queue_is_empty() && (global_msg_queue_full_flag == 0)){
		global_message_queue_add(EEPROM_read_message_queue_get());
	}
}

uint8_t global_message_queue_is_empty(){
	if((global_msg_queue_storage_index == global_msg_queue_processing_index) &&
			global_msg_queue_full_flag == 0){
		return 1;
	} else {
		return 0;
	}
}

uint8_t sensor_message_queue_is_empty(){
    if((sensor_msg_queue_storage_index == sensor_msg_queue_processing_index) &&
            sensor_msg_queue_full_flag == 0){
        return 1;
    } else {
        return 0;
    }
}

uint8_t server_message_queue_is_empty(){
    if((server_msg_queue_storage_index == server_msg_queue_processing_index) &&
            server_msg_queue_full_flag == 0){
        return 1;
    } else {
        return 0;
    }
}

uint8_t internal_message_queue_is_empty(){
    if((internal_msg_queue_storage_index == internal_msg_queue_processing_index) &&
            internal_msg_queue_full_flag == 0){
        return 1;
    } else {
        return 0;
    }
}

uint8_t EEPROM_read_message_queue_is_empty(){
    if((EEPROM_read_msg_queue_storage_index == EEPROM_read_msg_queue_processing_index) &&
    		EEPROM_read_msg_queue_full_flag == 0){
        return 1;
    } else {
        return 0;
    }
}

//Returns pointer to the next unprocessed message and updates processing pointer
uint8_t* global_message_queue_get(){
	uint8_t* msg_pointer = global_message_queue + global_msg_queue_processing_index;

	//Update the processing index
	global_msg_queue_processing_index = global_msg_queue_processing_index + MESSAGE_BLOCK_BYTES; //Places the index at the right spot for next write

	//Tests if the end of the message_queue has been reached - roll around to the start of the message array
	if(global_msg_queue_processing_index == GLOBAL_MESSAGE_QUEUE_SIZE){
		global_msg_queue_storage_index = 0;
	}

	return msg_pointer;
}

// Returns pointer to the next unprocessed message and updates processing pointer
uint8_t* sensor_message_queue_get(){
    uint8_t* msg_pointer = sensor_message_queue + sensor_msg_queue_processing_index;

    // Update the processing index
    sensor_msg_queue_processing_index = sensor_msg_queue_processing_index + MESSAGE_BLOCK_BYTES; // Places the index at the right spot for the next write

    // Tests if the end of the message_queue has been reached - roll around to the start of the message array
    if(sensor_msg_queue_processing_index == SENSOR_MESSAGE_QUEUE_SIZE){
        sensor_msg_queue_storage_index = 0;
    }

    return msg_pointer;
}

// Returns pointer to the next unprocessed message and updates processing pointer
uint8_t* server_message_queue_get(){
    uint8_t* msg_pointer = server_message_queue + server_msg_queue_processing_index;

    // Update the processing index
    server_msg_queue_processing_index = server_msg_queue_processing_index + MESSAGE_BLOCK_BYTES; // Places the index at the right spot for the next write

    // Tests if the end of the message_queue has been reached - roll around to the start of the message array
    if(server_msg_queue_processing_index == SERVER_MESSAGE_QUEUE_SIZE){
        server_msg_queue_storage_index = 0;
    }

    return msg_pointer;
}

// Returns pointer to the next unprocessed message and updates processing pointer
uint8_t* internal_message_queue_get(){
    uint8_t* msg_pointer = internal_message_queue + internal_msg_queue_processing_index;

    // Update the processing index
    internal_msg_queue_processing_index = internal_msg_queue_processing_index + MESSAGE_BLOCK_BYTES; // Places the index at the right spot for the next write

    // Tests if the end of the message_queue has been reached - roll around to the start of the message array
    if(internal_msg_queue_processing_index == INTERNAL_MESSAGE_QUEUE_SIZE){
        internal_msg_queue_storage_index = 0;
    }

    return msg_pointer;
}

// Returns pointer to the next unprocessed message and updates processing pointer
uint8_t* EEPROM_read_message_queue_get(){
    uint8_t* msg_pointer = EEPROM_read_message_queue + EEPROM_read_msg_queue_processing_index;

    // Update the processing index
    EEPROM_read_msg_queue_processing_index = EEPROM_read_msg_queue_processing_index + MESSAGE_BLOCK_BYTES; // Places the index at the right spot for the next write

    // Tests if the end of the message_queue has been reached - roll around to the start of the message array
    if(EEPROM_read_msg_queue_processing_index == EEPROM_READ_MESSAGE_QUEUE_SIZE){
    	EEPROM_read_msg_queue_processing_index = 0;
    }

    return msg_pointer;
}

void global_message_queue_add(uint8_t* message){
	if(global_msg_queue_full_flag == 0){
		//Store received messages in message_queue array and process them later
		for (uint8_t i = 0;i < MESSAGE_BLOCK_BYTES;i++){
			global_message_queue[global_msg_queue_storage_index+i] = *(message + i);
		}

		//Update storage index
		global_msg_queue_storage_index = global_msg_queue_storage_index + MESSAGE_BLOCK_BYTES; //Places the index at the right spot for next write

		//Tests if the end of the message_queue has been reached - roll around to the start of the message array
		if(global_msg_queue_storage_index == GLOBAL_MESSAGE_QUEUE_SIZE){
			global_msg_queue_storage_index = 0;
		}

		//Check if this operation filled up the message queue
		if(global_msg_queue_storage_index == global_msg_queue_processing_index){
			global_msg_queue_full_flag = 1;
		}

		Set_Pending_AES_RNG_LPUART1_Interrupt(); //Set PendSV interrupt to process message queues
	} else {
		//Update the device status bit
		device_status |= BIT2;
	}
}

void sensor_message_queue_add(uint8_t* message){
    if(sensor_msg_queue_full_flag == 0){
        //Store received messages in message_queue array and process them later
        for (uint8_t i = 0; i < MESSAGE_BLOCK_BYTES; i++){
            sensor_message_queue[sensor_msg_queue_storage_index + i] = *(message + i);
        }

        //Update storage index
        sensor_msg_queue_storage_index = sensor_msg_queue_storage_index + MESSAGE_BLOCK_BYTES; //Places the index at the right spot for next write

        //Tests if the end of the message_queue has been reached - roll around to the start of the message array
        if(sensor_msg_queue_storage_index == SENSOR_MESSAGE_QUEUE_SIZE){
            sensor_msg_queue_storage_index = 0;
        }

        //Check if this operation filled up the message queue
        if(sensor_msg_queue_storage_index == sensor_msg_queue_processing_index){
            sensor_msg_queue_full_flag = 1;
        }

        Set_Pending_AES_RNG_LPUART1_Interrupt(); //Set PendSV interrupt to process message queues
    } else {
        // Update the device status bit
        device_status |= BIT3;
    }
}

void server_message_queue_add(uint8_t* message){
    if(server_msg_queue_full_flag == 0){
        //Store received messages in message_queue array and process them later
        for (uint8_t i = 0; i < MESSAGE_BLOCK_BYTES; i++){
            server_message_queue[server_msg_queue_storage_index + i] = *(message + i);
        }

        //Update storage index
        server_msg_queue_storage_index = server_msg_queue_storage_index + MESSAGE_BLOCK_BYTES; //Places the index at the right spot for next write

        //Tests if the end of the message_queue has been reached - roll around to the start of the message array
        if(server_msg_queue_storage_index == SERVER_MESSAGE_QUEUE_SIZE){
            server_msg_queue_storage_index = 0;
        }

        //Check if this operation filled up the message queue
        if(server_msg_queue_storage_index == server_msg_queue_processing_index){
            server_msg_queue_full_flag = 1;
        }

        Set_Pending_AES_RNG_LPUART1_Interrupt(); //Set PendSV interrupt to process message queues
    } else {
        // Update the device status bit
        device_status |= BIT4;
    }
}

void internal_message_queue_add(uint8_t* message){
    if(internal_msg_queue_full_flag == 0){
        //Store received messages in message_queue array and process them later
        for (uint8_t i = 0; i < MESSAGE_BLOCK_BYTES; i++){
            internal_message_queue[internal_msg_queue_storage_index + i] = *(message + i);
        }

        //Update storage index
        internal_msg_queue_storage_index = internal_msg_queue_storage_index + MESSAGE_BLOCK_BYTES; //Places the index at the right spot for the next write

        //Tests if the end of the message_queue has been reached - roll around to the start of the message array
        if(internal_msg_queue_storage_index == INTERNAL_MESSAGE_QUEUE_SIZE){
            internal_msg_queue_storage_index = 0;
        }

        //Check if this operation filled up the message queue
        if(internal_msg_queue_storage_index == internal_msg_queue_processing_index){
            internal_msg_queue_full_flag = 1;
        }

        Set_Pending_AES_RNG_LPUART1_Interrupt(); //Set PendSV interrupt to process message queues
    } else {
        // Update the device status bit
        device_status |= BIT5;
    }
}

void EEPROM_read_message_queue_add(uint8_t* message){
    if(EEPROM_read_msg_queue_full_flag == 0){
        //Store received messages in message_queue array and process them later
        for (uint8_t i = 0; i < MESSAGE_BLOCK_BYTES; i++){
        	EEPROM_read_message_queue[EEPROM_read_msg_queue_storage_index + i] = *(message + i);
        }

        //Update storage index
        EEPROM_read_msg_queue_storage_index = EEPROM_read_msg_queue_storage_index + MESSAGE_BLOCK_BYTES; //Places the index at the right spot for the next write

        //Tests if the end of the message_queue has been reached - roll around to the start of the message array
        if(EEPROM_read_msg_queue_storage_index == EEPROM_READ_MESSAGE_QUEUE_SIZE){
        	EEPROM_read_msg_queue_storage_index = 0;
        }

        //Check if this operation filled up the message queue
        if(EEPROM_read_msg_queue_storage_index == EEPROM_read_msg_queue_processing_index){
        	EEPROM_read_msg_queue_full_flag = 1;
        }

        Set_Pending_AES_RNG_LPUART1_Interrupt(); //Set PendSV interrupt to process message queues
    } else {
        // Update the device status bit
        device_status |= BIT9;
    }
}
