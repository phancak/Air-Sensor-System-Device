/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h> //defines a set of fixed-size integer types with specified widths, such as int8_t, uint8_t, int16_t, uint16_t, int32_t, uint32_t,
#include "I2C_EEPROM.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint8_t EEPROM_send_data[MESSAGE_BLOCK_BYTES]={0}; //Data to be sent (page size plus address). The first two bytes of EEPROM_send_data reserved for EEPROM_address
uint8_t EEPROM_received_data[MESSAGE_BLOCK_BYTES]={0}; //Data received
uint16_t EEPROM_Transmitted_address[2] = {0}; //Two byte EEPROM address to be sent before data
uint8_t send_byte_counter = 0;
uint8_t receive_byte_counter = 0;  //Tracks position in the receive array
uint8_t i2c_busy = 0;
uint8_t i2c_write_successful_flag = 0;
uint8_t i2c_read_successful_flag = 0;
uint8_t no_of_write_attempts = 0;
uint16_t EEPROM_Data_Write_Address = 0;
uint16_t EEPROM_Data_Process_Address = 0;

//EEPROM 24AA256UID-I/P-ND - 256K I2C Serial EEPROM
//32K x 8 (256 Kbit)
//User Memory Area
//0000h -> 6fffh => 28671 bytes (uint8_t)

//PB6 I2C1 SSCL D5
//PB7 I2C1 SSDA D4
//SB16 Connect D5 to A5
//SB18 Connect D4 to A4

/*
int main(void)
{
	//ADC_IN1 PA1 Additional Function
	//ADC_IN2 PA2 Additional Function
	//Configure analog input

	intialize_Clock_HSI16();
	set_system_clock();
	intialize_NVIC_I2C1();
	initialize_I2C1_Clock();
	intialize_GPIOA_Clock();
	intialize_GPIOB_Clock();
	intialize_GPIO_I2C1();
	initialize_I2C1();

	EEPROM_Reset_Data_Pointers(EEPROM_CHIP1_ADDRESS); //Reset EEPROM write pointer and data block count (pointer on the EEPROM chip)

	//Prepare data to be sent
	for(int i=0;i<DATA_BLOCK_BYTES;i++){
		EEPROM_send_data[i]=i+30;
	}

	//I2C_EEPROM_Write(0x01, 0x0001, 63, 0x1);
	//I2C_EEPROM_Write(0x0003, 0x04);
	EEPROM_Store_Data_Block(EEPROM_CHIP1_ADDRESS); //Uses EEPROM_send_data (global variable)

	//Prepare data to be sent
	for(int i=0;i<DATA_BLOCK_BYTES;i++){
		EEPROM_send_data[i]=i+40;
	}

	EEPROM_Store_Data_Block(EEPROM_CHIP1_ADDRESS); //Uses EEPROM_send_data (global variable)
	I2C_EEPROM_Read(0x01, 0x0000, (DATA_BLOCK_BYTES*2+4));
*/
    /* Loop forever */
	//for(;;){
		//*pGPIOB_ODR &= ~(1 << 0); //Reset output for PB0
		//*pGPIOB_ODR |= ((*pI2C1_ISR >> 15) & 0x01); //PB0 = I2C_BUSY
		//*pGPIOB_ODR |= ((*pI2C1_ISR >> 0) & 0x01); //PB0 = I2C_TXE
	//}
//}

//Retrieves serial number information from specified chip
void EEPROM_Get_Serial_Number(uint8_t I2C_address){
	//Reads serial data information plus one byte before which will be overwritten with label
	I2C_EEPROM_Read(I2C_address, (EEPROM_MANUFACTURER_CODE-1), 0x07); //Reads into EEPROM_received_data
	label_message_type(0x07, I2C_address, EEPROM_received_data); //Seventh byte is labeled with the I2C_address chip address
	label_message_type(0x00, 0x06, EEPROM_received_data); //Seventh byte is labeled with the I2C_address chip address
	EEPROM_read_message_queue_add(EEPROM_received_data);
}

//Stored data blocks is available in the EEPROM and has not been processed
uint8_t EEPROM_Stored_Data_Block_Is_Available(uint8_t I2C_address){
	//1. Retrieve EEPROM_Data_Process_Address and EEPROM_Data_Write_Address (global variables are updated)
	EEPROM_Get_Data_Write_Pointer(I2C_address); //Updates EEPROM_Data_Write_Address (global)
	EEPROM_Get_Data_Process_Pointer(I2C_address); //Updates EEPROM_Data_Process_Address (global)

	//2. Test if there are any new stored data that have not been processed
	if (EEPROM_Data_Write_Address != EEPROM_Data_Process_Address){
		//New data are available
		return 1;
	} else {
		//No new data are available
		return 0;
	}
}

void EEPROM_Read_Device_Identifiers(uint8_t I2C_address){
	//Reads EEPROM device identifiers
	//1.Manufacturer code 1 byte
	//2.Device identifier 1 byte
	//3.Serial number     32 bit = 4 bytes
	I2C_EEPROM_Read(I2C_address, EEPROM_MANUFACTURER_CODE, 0x6);
}

void EEEPROM_Get_Data_Pointers(uint8_t I2C_address){
	//1. Retrieve EEPROM_Data_Write_Address and EEPROM_Data_Process_Address pointer (4 bytes)
	//	 Located at 0x0000 (uint16_t x 2)
	//   Received data are stored in EEPROM_received_data array (global) in first four bytes
	EEPROM_Get_Data_Write_Pointer(I2C_address);
	EEPROM_Get_Data_Process_Pointer(I2C_address);
}

void EEPROM_Reset_Data_Pointers(uint8_t I2C_address){
	//Reset the data block count and write pointer
	EEPROM_Data_Write_Address = EEPROM_INITIAL_DATA_WRITE_POINTER;
	EEPROM_Data_Process_Address = EEPROM_INITIAL_DATA_WRITE_POINTER;
	*(EEPROM_send_data) = (EEPROM_Data_Process_Address >> 8); //Block number High Byte
	*(EEPROM_send_data+1) = EEPROM_Data_Process_Address; //Block number Low Byte
	*(EEPROM_send_data+2) = (EEPROM_Data_Write_Address >> 8); //Address High Byte
	*(EEPROM_send_data+3) = EEPROM_Data_Write_Address; //Address Low Byte
	I2C_EEPROM_Write(I2C_address, EEPROM_DATA_BLOCK_PROCESS_POINTER, 0x4, 0x1);
}

//Gets the EEPROM_Data_Write_Address on EEPROM updating the current global variable
void EEPROM_Get_Data_Write_Pointer(uint8_t I2C_address){
	//1. Retrieve EEPROM_Data_Write_Address pointer (2 bytes)
	//   Received data are stored in EEPROM_received_data array (global) in first four bytes
	I2C_EEPROM_Read(I2C_address, EEPROM_DATA_BLOCK_WRITE_POINTER, 0x2);

	//Updates global variables
	EEPROM_Data_Write_Address = (((*(EEPROM_received_data+0)) << 8) | (*(EEPROM_received_data+1)));
}

//Gets the EEPROM_Data_Process_Address on EEPROM updating the current global variable
void EEPROM_Get_Data_Process_Pointer(uint8_t I2C_address){
	//1. Retrieve EEPROM_Data_Process_Address pointer (2 bytes)
	//   Received data are stored in EEPROM_received_data array (global) in first four bytes
	I2C_EEPROM_Read(I2C_address, EEPROM_DATA_BLOCK_PROCESS_POINTER, 0x2);

	//Updates global variables
	EEPROM_Data_Process_Address = (((*(EEPROM_received_data+0)) << 8) | (*(EEPROM_received_data+1)));
}

//Increments the EEPROM_Data_Write_Address on EEPROM using the current global variable
void EEPROM_Increment_Data_Write_Pointer(uint8_t I2C_address, uint16_t incrementSize){
	EEPROM_Data_Write_Address += incrementSize;

	//Prepares the send data global array
	*(EEPROM_send_data) = (EEPROM_Data_Write_Address >> 8); //High Byte
	*(EEPROM_send_data+1) = EEPROM_Data_Write_Address; //Low Byte

	//Transmits the data to EEPROM
	I2C_EEPROM_Write(I2C_address, EEPROM_DATA_BLOCK_WRITE_POINTER, 0x2, 0x1);
}

//Increments the EEPROM_Data_Process_Address on EEPROM using the current global variable
void EEPROM_Increment_Data_Process_Pointer(uint8_t I2C_address, uint16_t incrementSize){
	EEPROM_Data_Process_Address += incrementSize;

	//Prepares the send data global array
	*(EEPROM_send_data) = (EEPROM_Data_Process_Address >> 8); //High Byte
	*(EEPROM_send_data+1) = EEPROM_Data_Process_Address; //Low Byte

	//Transmits the data to EEPROM
	I2C_EEPROM_Write(I2C_address, EEPROM_DATA_BLOCK_PROCESS_POINTER, 0x2, 0x1);
}

void EEPROM_Store_Data_Block(uint8_t I2C_address){
	//1. Retrieve EEPROM_Data_Write_Address and EEPROM_Data_Process_Address pointer (4 bytes)
	//	 Located at 0x0000 (uint16_t x 2)
	//   Updates global variables
	EEPROM_Get_Data_Write_Pointer(I2C_address);

	//2.Write data block starting at the last pointer
	I2C_EEPROM_Write(I2C_address, EEPROM_Data_Write_Address, MESSAGE_BLOCK_BYTES, 0x1);

	//3.Update EEPROM_Data_Write_Address pointer. The first two bytes of EEPROM_send_data (global) reserved for EEPROM_address
	EEPROM_Increment_Data_Write_Pointer(I2C_address, MESSAGE_BLOCK_BYTES);
}

uint8_t EEPROM_Get_FIFO_Data_Block(uint8_t I2C_address){
	//1. Updates EEPROM_Data_Process_Address and EEPROM_Data_Write_Address (global variables are updated)
	if(EEPROM_Stored_Data_Block_Is_Available(I2C_address)){
		//2.Read data block starting at the last process pointer
		I2C_EEPROM_Read(I2C_address, EEPROM_Data_Process_Address, MESSAGE_BLOCK_BYTES);

		//3.Update EEPROM_Data_Process_Address pointer. The first two bytes of EEPROM_send_data (global) reserved for EEPROM_address
		EEPROM_Increment_Data_Process_Pointer(I2C_address, MESSAGE_BLOCK_BYTES);

		//4. Add data on the EEPROM received data processing queue
		label_message_type(0x0D, 0x01, EEPROM_received_data); //Labels block 13 with 1 (Came from EEPROM)
		EEPROM_read_message_queue_add(EEPROM_received_data);

		//New data were available
		return 1;
	} else {
		//No new data were available, EEPROM_received_data array is not updated
		return 0;
	}
}

/**
 * @brief Perform I2C EEPROM read operation.
 *
 * This function reads data from an I2C EEPROM. It initializes the read operation,
 * sends the control byte and EEPROM address using I2C_EEPROM_Write, and then prepares
 * the I2C bus for the read operation. The function ensures that the EEPROM address write
 * was successful before attempting to receive data.
 *
 * @param I2C_address The 4-bit address of the EEPROM.
 * @param EEPROM_address The memory address in the EEPROM to start reading from.
 * @param nBytes The number of bytes to read.
 *
 * @note The function assumes that I2C_EEPROM_Write has been defined and implements
 * the necessary write operation to set up the read operation.
 */
void I2C_EEPROM_Read(uint8_t I2C_address, uint16_t EEPROM_address, uint8_t nBytes) {

    // Initialize read operation
    receive_byte_counter = 0; // Tracks position in the receive array
    i2c_read_successful_flag = 0;

    // Master transmit control byte and two-byte EEPROM address to be read
    // No need to generate STOP condition
    // Master read - send control byte and receive bytes
    // To end read operation generate NACK and STOP
    I2C_EEPROM_Write(I2C_address, EEPROM_address, 0, 0x0); // Transmit control byte, address, restart

    // Will attempt to receive data only when the EEPROM address write was successful
    // EEPROM is not in a write cycle (address write was successful)
    // No need for pooling
    if (i2c_write_successful_flag == 1) {
        // Reinitialize for read operation
        I2C1_CR2 |= (0x51 << 1);  // SADD[7:1] Slave Address for 7-bit addressing
        I2C1_CR2 &= ~(0xFF << 16); // Clear NBYTES
        I2C1_CR2 |= (nBytes << 16); // NBYTES=data_size Number of bytes to be sent
        I2C1_CR2 |= (1 << 10);      // RD_WRN=1 Master Requests a Read Transfer
        // ------This causes STOP generation
        // I2C1_CR2 |= (1 << 25); // Set AUTOEND bit - STOP will set after NACK automatically

        // Start the read operation
        // One attempt only
        I2C1_CR2 |= (1 << 13); // START
        I2C1_CR2 |= (1 << 25); // Set AUTOEND bit - STOP will set after NACK automatically
        i2c_busy = 1;

        // Wait while I2C is busy before the next write - Blocks its own operation
        while (i2c_busy) {
            // Wait
        }
    }
}

// I2C_address is the 4-bit address of the EEPROM
// generateStop is here to allow this function to be used for EEPROM read operation
// generateStop == 1 generate STOP condition at the end of transmission
// generateStop == 0 Don't generate STOP
// The first two bytes of EEPROM_send_data reserved for EEPROM_address
void I2C_EEPROM_Write(uint8_t I2C_address, uint16_t EEPROM_address, uint8_t nBytes, uint8_t generateStop) {
    uint8_t control_byte = (0x50 | I2C_address); // Control byte 1010000

    // Prepare EEPROM address for transfer
    EEPROM_Transmitted_address[0] = (EEPROM_address >> 8);
    EEPROM_Transmitted_address[1] = (EEPROM_address);

    // Initialize i2c write operation
    i2c_write_successful_flag = 0; // Initialize flag
    no_of_write_attempts = 1; // Tally of current data write attempts
    send_byte_counter = 0; // Byte number tracker in the EEPROM_send_data array

    // Initializes the number of bytes to be sent from the EEPROM_send_data array
    I2C1_CR2 &= ~(0xFF << 0); // Clears the SADD[7:1]
    I2C1_CR2 |= (control_byte << 1); // SADD[7:1] Slave Address for 7-bit addressing
    I2C1_CR2 &= ~(0xFF << 16); // NBYTES=data_size Number of bytes to be sent
    I2C1_CR2 |= ((nBytes+0x2) << 16); // NBYTES=data_size Number of bytes to be sent, plus two for the EEPROM_address
    I2C1_CR2 &= ~(1 << 10); // RD_WRN=0 Master Requests a Write Transfer
    I2C1_CR2 &= ~(1 << 25); // Clear AUTOEND bit
    I2C1_CR2 |= (generateStop << 25); // AUTOEND Stop Condition is Automatically sent after NBYTES
    I2C1_CR1 &= ~(1 << 6); // Clear TCIE
    // When STOP is not generated (AUTOEND = 0), transmission will end after the last ACK
    if (generateStop == 0) {
        I2C1_CR1 |= (1 << 6); // TCIE: Transfer Complete interrupt enable
    }

    // Start write operation
    while (i2c_write_successful_flag == 0 && (no_of_write_attempts <= I2C_MAX_EEPROM_WRITE_ATTEMPTS)) {
        I2C1_CR2 |= (1 << 13); // START
        i2c_busy = 1;

        // Wait while I2C is busy before the next write - Blocks its own operation
        while (i2c_busy) {
            // Wait
        }
    }
}

void I2C1_IRQHandler(){
	//Detects empty I2C1_TXDR TXIS: Transmit Interrupt Status = 1
	if(I2C1_ISR & (1<<1)){
		//Interrupt flag cleared automatically
		if (send_byte_counter<2){
			I2C1_TXDR = *(send_byte_counter+EEPROM_Transmitted_address); //Sends EEPROM address first
		} else {
			I2C1_TXDR = *((send_byte_counter-2)+EEPROM_send_data); //TXDATA[7:0] 8bit transmit data
		}
		send_byte_counter=send_byte_counter+1;
	}

	//Detects RXNE=1: Receive data register not empty (receivers)
	if(I2C1_ISR & (1<<2)){
		//Interrupt flag cleared automatically
		*(receive_byte_counter+EEPROM_received_data) = I2C1_RXDR; //RXDATA[7:0] 8bit transmit data
		receive_byte_counter=receive_byte_counter+1;
	}

	//Detects Bit 4 NACKF: Not Acknowledge received flag
	/*if(I2C1_ISR & (1<<4)){
		//It is cleared by software by setting the NACKCF bit.
		//I2C1_ICR |= (1 << 4); //Clears the NACKF flag in I2C1_ISR register.
		//I2C1_CR2 |= (1 << 14); //STOP=1 Stop Generation after current byte transfer
		nack_counter = nack_counter + 1;
	}*/

	//Detects Bit 6 TC: Transfer Complete (master mode)
	//Memory address is sent to EEPROM (without STOP) - new data read follows
	if(I2C1_ISR & (1<<6)){
		//It is cleared by software when START bit or STOP bit is set.
		//Will be cleared on START of data read from EEPROM
		i2c_write_successful_flag = 1; //I2C write was successful
		I2C1_CR1 &= ~(1 << 6); //Disable TCIE
		i2c_busy = 0;
	}

	//Detects Bit 5 STOPF: Stop detection flag
	//It is cleared by software by setting the STOPCF bit.
	if(I2C1_ISR & (1<<5)){
		//For EEPROM write (RD_WRN=0)
		if((I2C1_CR2 & (1 << 10))==0) { //Bit 10 RD_WRN: Transfer direction (master mode)
			if (I2C1_ISR & (1 << 4)){ //NACKF detected (before the current STOP) - EEPROM is busy writing other data (Not responsive)
				I2C1_ICR |= (1 << 4); //Clears the NACKF flag in I2C1_ISR register.
				no_of_write_attempts = no_of_write_attempts + 1;
			} else {
				i2c_write_successful_flag = 1; //I2C write was successful
			}
			I2C1_ICR |= (1 << 5); //Clears the STOPF flag in the I2C1_ISR register.
			//I2C1_CR2 |= (1 << 14); //STOP=1 Stop Generation after current byte transfer
			//stop_counter = stop_counter + 1;
			i2c_busy = 0;
		} else if(I2C1_CR2 & (1 << 10)){ //For EEPROM read (RD_WRN=1)
			if (I2C1_ISR & (1 << 4)){ //NACKF detected (before the current STOP)
				I2C1_ICR |= (1 << 4); //Clears the NACKF flag in I2C1_ISR register.
				//i2c_write_successful_flag is left at zero
			} else {

				//No NACK was detected during EEPROM READ operation
				i2c_read_successful_flag = 1; //I2C write was successful
			}
			I2C1_ICR |= (1 << 5); //Clears the STOPF flag in the I2C1_ISR register.
			//I2C1_CR2 |= (1 << 14); //STOP=1 Stop Generation after current byte transfer
			//stop_counter = stop_counter + 1;
			i2c_busy = 0;
		}
	}
}

void intialize_GPIO_I2C1(){
	//Set GPIO registers
	//PB6 I2C1 SSCL D5
	//PB7 I2C1 SSDA D4
	//SB16 Connect D5 to A5
	//SB18 Connect D4 to A4

	// Set GPIO registers
	GPIOA_MODER &= ~(0x3 << 10); // 00: Input mode for PA5
	GPIOA_MODER &= ~(0x3 << 12); // 00: Input mode for PA6
	GPIOA_OSPEEDR |= (1 << 11); // 10: High speed mode for PA5
	GPIOA_OSPEEDR &= ~(1 << 10);
	GPIOA_OSPEEDR |= (1 << 13); // 10: High speed mode for PA6
	GPIOA_OSPEEDR &= ~(1 << 12);
	GPIOA_OTYPER &= ~(1 << 5); // 0: Output push-pull (reset state)
	GPIOA_OTYPER &= ~(1 << 6); // 0: Output push-pull (reset state)
	GPIOA_PUPDR &= ~(0x3 << 10); // 00: No pull-up, pull-down PA5 (floating)
	GPIOA_PUPDR &= ~(0x3 << 12); // 00: No pull-up, pull-down PA6 (floating)

	// Set Port B
	GPIOB_MODER |= (1 << 13); // 10: Alternate function mode for PB6
	GPIOB_MODER &= ~(1 << 12);
	GPIOB_MODER |= (1 << 15); // 10: Alternate function mode for PB7
	GPIOB_MODER &= ~(1 << 14);
	GPIOB_OSPEEDR |= (1 << 13); // 10: High speed mode for PB6
	GPIOB_OSPEEDR &= ~(1 << 12);
	GPIOB_OSPEEDR |= (1 << 15); // 10: High speed mode for PB7
	GPIOB_OSPEEDR &= ~(1 << 14);
	GPIOB_OTYPER |= (1 << 6); // 1: Open Drain (MOSFET) - Line can be released
	GPIOB_OTYPER |= (1 << 7); // 1: Open Drain (MOSFET)
	GPIOB_PUPDR &= ~(0x3 << 12); // Clear bits 11 and 12 PB6
	GPIOB_PUPDR &= ~(0x3 << 14); // Clear bits 13 and 14 PB7
	GPIOB_PUPDR |= (1 << 12); // 01: Pull-up mode for PB6
	GPIOB_PUPDR &= ~(1 << 13);
	GPIOB_PUPDR |= (1 << 14); // 01: Pull-up mode for PB7
	GPIOB_PUPDR &= ~(1 << 15);
	GPIOB_AFRL |= (0x1 << 24); //Alternate function 1 for PB6
	GPIOB_AFRL |= (0x1 << 28); //Alternate function 1 for PB7
}

void initialize_I2C1(){
	// Set I2C registers
	I2C1_CR1 &= ~(1 << 0); // PE=0 Disable peripheral
	I2C1_CR1 |= (1 << 8); // DNF=0001 Enable digital noise filter
	I2C1_TIMINGR |= (0x3 << 28); // PRESC=3
	I2C1_TIMINGR |= (0x4 << 20); // SCLDEL=4
	I2C1_TIMINGR |= (0x2 << 16); // SCLDADEL=2
	I2C1_TIMINGR |= (0xC3 << 8); // SCLH=0xC3 SCL High Period (Master Mode)
	I2C1_TIMINGR |= (0xC7 << 0); // SCLL=0xC7 SCL Low Period (Master Mode)
	I2C1_CR1 &= ~(1 << 17); // Clock Stretching Enabled (Default)
	I2C1_CR1 |= (1 << 4); // NACKIE=1: Not acknowledge received Interrupt enable
	I2C1_CR1 |= (1 << 5); //STOPIE: Stop detection Interrupt enable
	I2C1_CR1 |= (1 << 0); // PE=1 Peripheral Enable
	I2C1_CR2 &= ~(1 << 11); // 7-bit Addressing mode (default)
	//I2C1_CR2 |= (data_size << 16); //NBYTES=data_size Number of bytes to be sent
	//I2C1_CR2 |= (1 << 14); //STOP=1 Stop Generation after current byte transfer
	//I2C1_CR2 &= ~(1 << 10); //RD_WRN=0 Master Requests a Write Transfer
	//I2C1_CR2 |= (1 << 10); //RD_WRN=1 Master Requests a Read Transfer
	//I2C1_CR2 |= (1 << 25); //AUTOEND=1 Stop Condition is Automatically sent after NBYTES
	I2C1_CR2 |= (0x51 << 1); //SADD[7:1] Slave Address for 7bit addressing
	I2C1_CR1 |= (1 << 1); //TXIE: TX Interrupt enable TXDR should be filled
	I2C1_CR1 |= (1 << 2); //RXIE Interrupt enable RXDR should be read
	//I2C1_CR1 |= (1 << 15); //RXDMAEN: DMA reception requests enable 1: DMA mode enabled for reception
	//I2C1_CR1 |= (1 << 14); //TXDMAEN: DMA transmission requests enable 1: DMA mode enabled for transmission
	//I2C1_CR2 |= (1 << 13); //START
}
