/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "USART_DMA.h"

//MESSAGE_BLOCK_BYTES - Every message sent through UART has a constant size in bytes
uint8_t usart2_TX_buffer[MESSAGE_BLOCK_BYTES] = {0};
uint8_t usart2_RX_buffer[MESSAGE_BLOCK_BYTES] = {0};
uint8_t USART_transmission_in_progress_flag = 0; //When TX line active

//GND OF USB CHIP AND MCU MUST BE CONNECTED TO WORK CORRECTLY
/*
int main(void)
{
	//PIN1 D1 PA9 USART2_TX(1)
	//PIN2 D0 PA10 USART2_RX(1)

	// Port A PIN1 D1 PA9 USART2_TX(1), PIN2 D0 PA10 USART2_RX(1)
	// PA0 USART2_CTS AF4, PA1 USART2_RTS/USART2_DE AF4

	//Notes
	//Number of reception data blocks is reset when data are received
	//Must be reentered
	//Transmission setup
	//Enable everything, keep TE=1, Start the transmission by setting the number of data blocks to transmit
	//(To avoid Zero data block at the start after idle preamble)
	//The number of data blocks gets reset after transmission
	//Must be set each time before transmission
	//(Transmission is not started by TE=1)

	intialize_Clock();
	intialize_NVIC_USART2();
	intialize_NVIC_DMA_CH47();
	initialize_USART2_Clock();
	intialize_GPIOA_Clock();
	initialize_DMA_Clock();
	initialize_USART2_DMA();
	intialize_GPIO_USART2();
	initialize_USART2();

	//Initialize transmit data
	*usart2_TX_buffer = (uint8_t)'a'; //0x61;
	*(usart2_TX_buffer+1) = (uint8_t)'b';
	*(usart2_TX_buffer+2) = (uint8_t)'c';
	*(usart2_TX_buffer+3) = (uint8_t)'d';

	//-------Specify the number of data to be received or transfered (data expected)
	USART2_Set_Reception_Blocks(UART_RECEIVE_BUFFER_SIZE);
	USART2_Reception_Enable();
	//USART2_Send_Data(((uint16_t)4));
*/
    /* Loop forever */
	//for(;;);
//}

void Usart2_Copy_Into_TX_Buffer(uint8_t* message){
	for(int i=0;i < MESSAGE_BLOCK_BYTES;i++){
		*(usart2_TX_buffer + i) = *(message + i);
	}
}

void Usart2_Process_RX_Buffer(){
	//Checks if the message array is full
	if(server_msg_queue_full_flag == 0){
		//Store received messages in message_queue array and process them later
		//DMA_Set_Ch1_Destination();
		//DMA_Start_Ch1_Transfer();
		server_message_queue_add(usart2_RX_buffer);
	} else {
		//Do something when the array is full
		//Maybe go into error state
	}
}

void USART2_Send_Data(uint16_t noDataBlocks){ //DMA Transmission

	//BUSY: Busy flag, It is active when a communication is ongoing on the RX line
	while (USART_ISR & BIT16);

	//Waits for any ongoing transmission to complete
	while (USART_transmission_in_progress_flag == 1){
		//Transmission in progress
	}

	USART_transmission_in_progress_flag = 1; //Set transmission in progress flag

	//Clear the TC flag in the USART_ISR register by setting the TCCF bit in the USART_ICR register.
	USART_ICR |= BIT6; //Bit 6 TCCF: Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the USART_ISR register.

	USART_CR1 |= BIT6; //TCIE: Transmission complete interrupt enable, 1: A USART interrupt is generated whenever TC=1 in the USART_ISR register
	USART2_Transmission_Enable(); // TE: Transmitter enable

	//Setting the number of transmission data blocks with everything enabled should start the transmission
	USART2_Set_Transmission_Blocks(noDataBlocks);

	//DMA Transmission starts - Completed through interrupt
}

void initialize_USART2(){
	/*Character transmission procedure
	1. Program the M bits in USART_CR1 to define the word length.
	2. Select the desired baud rate using the USART_BRR register.
		To obtain 9600 baud with fCK = 16 MHz. (HSI = 16 MHZ)
		• In case of oversampling by 16: Oversampling by 16 (OVER8 = 0)
		USARTDIV = 16 000 000/9600
		BRR = USARTDIV = 1667d = 0683h
		• In case of oversampling by 8: Oversampling by 8 (OVER8 = 1)
		USARTDIV = 2 * 16 000 000/9600
		USARTDIV = 3333,33 (3333d = D05h)
		BRR[3:0] = 5h >> 1 = 2h
		BRR = 0xD02
	3. Program the number of stop bits in USART_CR2.
	4. Enable the USART by writing the UE bit in USART_CR1 register to 1.
	5. Select DMA enable (DMAT) in USART_CR3 if multibuffer communication is to take
	place. Configure the DMA register as explained in multibuffer communication.
	6. Set the TE bit in USART_CR1 to send an idle frame as first transmission.
	7. Write the data to send in the USART_TDR register (this clears the TXE bit). Repeat this
	for each data to be transmitted in case of single buffer.
	8. After writing the last data into the USART_TDR register, wait until TC=1. This indicates
	that the transmission of the last frame is complete. This is required for instance when
	the USART is disabled or enters the Halt mode to avoid corrupting the last
	transmission.*/

	// USART Registers
	USART_CR1 &= ~(1 << 0); // UE: USART enable 0: USART prescaler and outputs disabled, low-power mode
	USART_CR1 &= ~(1 << 28); // Bit 28 M1: Word length M[1:0] = 00: 1 Start bit, 8 data bits, n stop bits
	USART_CR1 &= ~(1 << 12); // Bit 12 M0: Word length (both M1 and M0 = M[1:0])
	//USART_CR1 |= (1 << 7); //TXEIE: interrupt enable 1: A USART interrupt is generated whenever TXE=1 in the USART_ISR register
	//USART_CR1 |= (1 << 5); //RXNEIE: RXNE interrupt enable 1: A USART interrupt is generated whenever ORE=1 or RXNE=1 in the USART_ISR register
	//--USART_ICR |= BIT6; //Bit 6 TCCF: Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the USART_ISR register.
	//--USART_CR1 |= BIT6; //TCIE: Transmission complete interrupt enable, 1: A USART interrupt is generated whenever TC=1 in the USART_ISR register
	USART_BRR |= (0x683 << 0); // BRR[15:4] = USARTDIV[15:4] = 0683h and When OVER8 = 0, BRR[3:0] = USARTDIV[3:0].
	USART_CR2 &= ~(0x3 << 12); // STOP[1:0]: STOP bits 00: 1 stop bit (default)
	//USART_CR3 |= BIT8; //RTSE: RTS enable, 1: RTS output enabled, data is only requested when there is space in the receive buffer.
	//USART_CR3 |= BIT9; //CTSE: CTS enable, 1: CTS mode enabled, data is only transmitted when the CTS input is deasserted (tied to 0).
	USART_CR1 |= (1 << 0); // UE: USART enable 1: USART enabled
	USART_CR3 |= (1 << 7); //DMAT: DMA enable transmitter 1: DMA mode is enabled for transmission
	USART_CR3 |= (1 << 6); //DMAR: DMA enable receiver 1: DMA mode is enabled for reception
	USART_CR1 |= (1 << 2); //RE: Receiver enable 1: Receiver is enabled and begins searching for a start bit
	//USART_ICR |= BIT6; //Bit 6 TCCF: Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the USART_ISR register.
	//USART_CR1 |= BIT6; //TCIE: Transmission complete interrupt enable, 1: A USART interrupt is generated whenever TC=1 in the USART_ISR register

	// PA0 USART2_CTS AF4, PA1 USART2_RTS/USART2_DE AF4
	//USART2_Transmission_Enable(); // TE: Transmitter enable

	//The TE bit must be set before writing the data to be transmitted to the USART_TDR.
}

void initialize_USART2_DMA(){
	//Notes
	//Reception using DMA, transfer complete: TCIF=1 in DMA_ISR
	//Transmission using DMA, transfer complete: Software waits until TC=1 (Not DMA interrupt)
	//Reception size is always UART_RECEIVE_BUFFER_SIZE

	//Set DMA Registers
	DMA_CSELR |= (0x4 << 12); //USART2_TX on ch4
	DMA_CSELR |= (0x4 << 16); //USART2_RX on ch5
	DMA_CPAR4 = &USART_TDR; //It contains the base address of the peripheral data register from/to which the data will be read/written.
	DMA_CPAR5 = &USART_RDR;
	DMA_CMAR4 |= (uint32_t)usart2_TX_buffer; //It contains the base address of the memory from/to which the data will be read/written.
	DMA_CMAR5 |= (uint32_t)usart2_RX_buffer;
	//DMA_CNDTR4 = UART_TRANSFER_BUFFER_SIZE; //NDT[15:0]: number of data to transfer ch4 (send)
	DMA_CNDTR5 = MESSAGE_BLOCK_BYTES; //NDT[15:0]: number of data to transfer ch5 (receive)
	DMA_CCR4 |= (0x2 << 12); //PL[1:0]: priority level - High
	DMA_CCR5 |= (0x3 << 12); //PL[1:0]: priority level - Very high (Receive with highest priority)
	DMA_CCR4 |= (0x1 << 4); //DIR: data transfer direction 1: read from memory
	DMA_CCR5 &= ~(1 << 4); //DIR: data transfer direction 0: read from peripheral
	DMA_CCR4 &= ~(1 << 6); //PINC: peripheral increment mode - Automatic increment for the next block transfer
	DMA_CCR5 &= ~(1 << 6); //PINC: peripheral increment mode
	DMA_CCR4 |= (1 << 7); //MINC: memory increment mode - Automatic increment for the next block transfer
	DMA_CCR5 |= (1 << 7); //MINC: memory increment mode - Otherwise only sends the first term
	DMA_CCR4 &= ~(0x2 << 8); //PSIZE[1:0]: peripheral size 00: 8 bits
	DMA_CCR5 &= ~(0x2 << 8); //PSIZE[1:0]: peripheral size 00: 8 bits
	DMA_CCR4 &= ~(0x2 << 10); //MSIZE[1:0]: memory size 00: 8 bits
	DMA_CCR5 &= ~(0x2 << 10); //MSIZE[1:0]: memory size 00: 8 bits
	//DMA_CCR4 |= (0x1 << 1); //TCIE: transfer complete interrupt enable
	DMA_CCR5 |= (0x1 << 1); //TCIE: transfer complete interrupt enable. Reception using DMA transfer complete: TCIF=1 in DMA_ISR
	DMA_CCR4 |= (1 << 0); //EN: channel enable
	DMA_CCR5 |= (1 << 0); //EN: channel enable

	//Set up memory to memory transfer for after UART reception - usart2_RX_buffer to message_queue
	/*
	 * Memory-to-memory mode
	The DMA channels may operate without being triggered by a request from a peripheral. This
	mode is called memory-to-memory mode, and is initiated by software.
	If the MEM2MEM bit in the DMA_CCRx register is set, the channel, if enabled, initiates
	transfers. The transfer stops once the DMA_CNDTRx register reaches zero.
	Note: The memory-to-memory mode must not be used in circular mode. Before enabling a
	channel in memory-to-memory mode (MEM2MEM = 1), the software must clear the CIRC
	bit of the DMA_CCRx register.
	 */
	DMA_CCR1 &= ~BIT5; //CIRC: circular mode, 0: disabled, It must not be written when the channel is enabled (EN = 1).
	DMA_CCR1 |= (0x03 << 12);//PL[1:0]: priority level, 11: very high
	DMA_CCR1 &= ~(0x03 << 10); //MSIZE[1:0]: memory size, 00: 8 bits
	DMA_CCR1 &= ~(0x03 << 8); //PSIZE[1:0]: peripheral size, 00: 8 bits
	DMA_CCR1 |= BIT7; //MINC: memory increment mode, 1: enabled, It must not be written when the channel is enabled (EN = 1).
	DMA_CCR1 |= BIT6; //PINC: peripheral increment mode, 1: enabled, It must not be written when the channel is enabled (EN = 1).
	DMA_CCR1 |= BIT14; //MEM2MEM: memory-to-memory mode, 1: enabled, It must not be written when the channel is enabled (EN = 1).
	DMA_CCR1 |= BIT4; //DIR: data transfer direction, 1: read from memory
	DMA_CCR1 |= BIT3; //TEIE: transfer error interrupt enable, 1: enabled
	DMA_CNDTR1 = MESSAGE_BLOCK_BYTES; //NDT[15:0]: number of data to transfer
	//DMA_CPAR1 = message_queue; //PA[31:0]: peripheral address - Destination set at run time
	DMA_CMAR1 |= (uint32_t)usart2_RX_buffer; //MA[31:0]: peripheral address

	//DMA_CCR1 |= BIT0; //EN: channel enable, Starts channel transfer
}

void DMA_Set_Ch1_Destination(){
	//Set before each DMA transfer, channel disabled after each transfer
	DMA_CPAR1 = (server_message_queue + server_msg_queue_storage_index); //PA[31:0]: peripheral address
}

void DMA_Start_Ch1_Transfer(){
	DMA_CCR1 &= ~BIT0; //EN: channel enable, Disable
	DMA_IFCR |= BIT1; //CTCIF1: transfer complete flag clear for channel 1
	DMA_CNDTR1 = MESSAGE_BLOCK_BYTES; //NDT[15:0]: number of data to transfer
	DMA_IFCR |= BIT3; //CTEIF1: transfer error flag clear for channel 1, clear the TEIFx bit of the DMA_ISR register
	DMA_CCR1 |= BIT0; //EN: channel enable, Starts channel transfer
}

void USART2_Reception_Disable(){
	USART_CR1 &= ~BIT2; //RE: Receiver enable, 0: Receiver is disabled
}

void USART2_Reception_Enable(){
	USART_CR1 |= BIT2; //RE: Receiver enable 1: Receiver is enabled and begins searching for a start bit
}

void USART2_Transmission_Disable(){
	USART_CR1 &= ~BIT3; //TE: Transmitter enable 0: Transmitter is disabled
}

void USART2_Transmission_Enable(){
	USART_CR1 |= BIT3; // TE: Transmitter enable, 1: Transmitter is enabled
}

//Sets the number of transmitted data blocks that cause transmission complete interrupt
void USART2_Set_Transmission_Blocks(uint16_t noDataBlocks){
	//Number of receive data blocks is set when DMA channel is disabled
	DMA_CCR4 &= ~BIT0; //EN: channel enable, 0: disabled
	DMA_CNDTR4 = noDataBlocks; //NDT[15:0]: number of data to transfer ch5 (receive)
	DMA_CCR4 |= BIT0; //EN: channel enable, 1: enabled
}

//Sets the number of received data blocks that cause reception complete interrupt
void USART2_Set_Reception_Blocks(uint16_t noDataBlocks){
	//Number of receive data blocks is set when DMA channel is disabled
	DMA_CCR5 &= ~BIT0; //EN: channel enable, 0: disabled
	DMA_CNDTR5 = noDataBlocks; //NDT[15:0]: number of data to transfer ch5 (receive)
	DMA_CCR5 |= BIT0; //EN: channel enable, 1: enabled
}

//For transmission
void USART2_IRQHandler(){
	//Transmission using DMA, transfer complete: Software waits until TC=1 (USART)
	if (USART_ISR & BIT6){ //Transmission Completed
		USART_ICR |= BIT6; //Bit 6 TCCF: Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the USART_ISR register.
		DMA_IFCR |= (1 << 13); //Bit 13 CTCIF4: transfer complete flag clear for channel 4
		USART2_Transmission_Disable(); // TE: Transmitter enable, 0: Transmitter is disabled
		USART_CR1 &= ~BIT6; //TCIE: Transmission complete interrupt enable, 0: Interrupt is inhibited
		USART_transmission_in_progress_flag = 0; //Transmission complete
	}
}

//For reception
void DMA1_Channel4_7_IRQHandler(){
	//Reception using DMA transfer complete: TCIF=1 in DMA_ISR
	//Signals when specified number of data blocks has been transfered
	if(DMA_ISR & (1 << 17)){ //Bit 17 TCIF5: transfer complete (TC) flag for channel 5, 1: a TC event occurred
		DMA_IFCR |= (1 << 17); //Bit 17 CTCIF5: transfer complete flag clear for channel 5
		USART_ICR |= BIT6; //Bit 6 TCCF: Transmission complete clear flag. Writing 1 to this bit clears the TC flag in the USART_ISR register.
		//NDT[15:0]: number of data to transfer ch5 (receive) is reset
		USART2_Set_Reception_Blocks(MESSAGE_BLOCK_BYTES); //Must set this to receive another UART message
		Usart2_Process_RX_Buffer();
		//DMA channel must enabled again after each transfer
		//First clear the TEIFx bit of the DMA_ISR register
	}

	//Deal with DMA transfer error interrupts - Error interrupts have been enabled
	//Put the device into error state
}
