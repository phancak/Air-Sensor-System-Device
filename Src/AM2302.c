/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

//Digital relative humidity & temperature sensor AM2302/DHT22
//Use PA0 A0 as SIG

#include <stdint.h>
#include "AM2302.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

uint8_t data[42] = {0};
uint8_t data_low[42] = {0};
uint8_t check_sum = 0;

/*
int main(void)
{
	initialize_GPIOA_OD_PU((uint8_t)0);
	Assert_GPIOA_Output((uint8_t)0);

	uint8_t i =0;
	i = AM2302_Request_Data(&RH_data, &temperature_data);
*/
    /* Loop forever */
	//for(;;);
//}

/*
 * The GPIO port is setup as output drain initially and has the output set as
 * 1 which leaves the port in Hi-Z, wire = VDD (set high).
 */
uint8_t AM2302_Request_Data(uint16_t *pRH_data, uint16_t *pTemperature_data){
	uint8_t Check_sum = 0;
	uint8_t i = 0; //Cycle tracker
	uint8_t sampling_counter = 0;

	/* Note: Open Drain
	- Open drain mode: A “0” in the Output register activates the N-MOS whereas a “1”
	in the Output register leaves the port in Hi-Z (the P-MOS is never activated)
	– Push-pull mode: A “0” in the Output register activates the N-MOS whereas a “1” in
	the Output register activates the P-MOS
	*/

	//Initialize port
	GPIOA_MODER &= ~(0x3 << 0); //Reset for PA0
	GPIOA_MODER |= (0x1 << 0); //01: General purpose output mode for PA0
	GPIOA_ODR |= (1 << 0); //Set PA0 output to 1 leaves the port in Hi-Z, wire = VDD

	//Step 1: MCU send out start signal to AM2302 and AM2302 send response signal to MCU

	pause_us(5); //100 = 10ms
	GPIOA_ODR &= ~(1 << 0); //Set PA0 output to 0 activates the N-MOS
	pause_us(2000); //10 = 1ms (Host pulls low for a minimum of 1ms) 30
	GPIOA_ODR |= (1 << 0); //Set PA0 output to 1 leaves the port in Hi-Z, wire = VDD

	/* WORKS
	GPIOA_ODR |= (1 << 0); //Set PA0 output to 1 leaves the port in Hi-Z, wire = VDD
	pause_us(5); //100 = 10ms
	GPIOA_ODR &= ~(1 << 0); //Set PA0 output to 0 activates the N-MOS
	pause_us(10); //10 = 1ms (Host pulls low for a minimum of 1ms)
	GPIOA_ODR |= (1 << 0); //Set PA0 output to 1 leaves the port in Hi-Z, wire = VDD
	pause_us(5000); //Host pulls up and lea
	GPIOA_ODR &= ~(1 << 0); //Set PA0 output to 0 activates the N-MOS
	pause_us(10);
	GPIOA_ODR |= (1 << 0); //Set PA0 output to 1 leaves the port in Hi-Z, wire = VDD
	pause_us(100); //Release the wire for 10 us (20 ms)
	GPIOA_ODR &= ~(1 << 0); //Set PA0 output to 0 activates the N-MOS
	*/

	//Step 2: AM2302 send data to MCU

	//Detects data from the AM2302/DHT22 sensor
	GPIOA_MODER &= ~(0x3 << 0); //00: Input mode for PA0
	for(i=0;i<42;i++){
		//Tracks the length of time when the signal is set
		sampling_counter=0;
		while((GPIOA_IDR & (0x01<<0))==1 && sampling_counter<AM2302_TIMEOUT){
			//wait
			sampling_counter++;
		}
		data[i]=sampling_counter;

		//Waits while the signal is low
		sampling_counter=0;
		while((GPIOA_IDR & (0x01<<0))==0 && sampling_counter<AM2302_TIMEOUT){
			//wait
			sampling_counter++;
		}
		data_low[i]=sampling_counter;
	}

	//Step 3: Process the data
	uint8_t j = 0; //Data array tracker
	for(i=0;i<40;i++){
		j=i+2;
		if(i<16){
			*pRH_data <<= 1; //x <<= 2; equivalent to x = x << 2;
			if (data[j]>=AM2302_TIME_DATA0 && data[j]<AM2302_TIMEOUT)
				*pRH_data |= 0x01;
			else if (data[j]>=AM2302_TIMEOUT)
				return 1; //The counter timed out
		} else if (i>=16 && i<32){
			*pTemperature_data <<= 1;
			if (data[j]>=AM2302_TIME_DATA0 && data[j]<AM2302_TIMEOUT)
				*pTemperature_data |= 0x01;
			else if (data[j]>=AM2302_TIMEOUT)
				return 1; //The counter timed out
		} else {
			Check_sum <<= 1;
			if (data[j]>=AM2302_TIME_DATA0 && data[j]<AM2302_TIMEOUT)
				Check_sum |= 0x01;
			else if (data[j]>=AM2302_TIMEOUT)
				return 1; //The counter timed out
		}
	}

	//Step 4: Check sum
	uint8_t a = (uint8_t)(*pRH_data>>8);
	uint8_t b = (uint8_t)(*pRH_data);
	uint8_t c = (uint8_t)(*pTemperature_data>>8);
	uint8_t d = (uint8_t)(*pTemperature_data);
	uint8_t e = a+b+c+d;
	if (e==Check_sum)
		return 0; //Transfer successful
	else
		return 2; //Check_sum failed
}

void pause_us(uint32_t n){
	//For 16Mhz clock speed 10 count = 1ms
	uint32_t i = 0;
	uint32_t j = n;
	for(i = 0; i < (j); i++);
}
